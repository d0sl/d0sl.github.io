[
{
	"uri": "https://d0sl.org/en/quick/chess/sample/",
	"title": "Project details",
	"tags": [],
	"description": "",
	"content": " To run the chess sample  Find a semantic model ChessAII in org.d0sl.examples/sandbox Open the context menu on it by pressing the right mouse button. And select Run Node ChessAII.  To change semantic Semantic model is defined in sandbox/ChessAII. When the robot places the queens it calls check board predicate. In the semantic model in advance prepared several different predicates check board. Just change the name of the current check board predicate, and rename some other (e.g. check board1 name to check board. And you can see how the behavior of the robot changes depending on the given semantics.\nFor example, the following model will forbid a robot to put queens on one line, but he will be able to arrange them on one diagonal.\ndef check board2(board : ChessBoard) means check all var queens = ChessDSL.get queens(board) for all q1, q2 in queens not ChessDSL.on one line(q1, q2) end end def  After each change of the model, do not forget to rebuild the MPS solution (Ctrl+F9).  Java part You can find the Java part of the example in org.d0sl.examples/chess\n First of all, pay attention to the ChessDSL class, which, using annotations, indicates the domain specific functions to which we refer in our semantic model. For example\n /** Represents a DSL for task: Arrangement of chess queens */ @DomainModel(name = \u0026quot;ChessDSL\u0026quot;) public class ChessDSL { \u0026lt;...SKIPPED...\u0026gt; /** Check if two queens are in the same horizontal or vertical @param @return */ @DomainFunction(name = \u0026quot;on one line\u0026quot;) public boolean onOneLine(ChessQueen q1, ChessQueen q2) { if (q1.getCol() == q2.getCol() || q1.getRaw() == q2.getRaw()) { return true; } return false; } /** Check if two queens are in the same diagonal @param @return */ @DomainFunction(name = \u0026quot;on one diagonal\u0026quot;) public boolean onOneDiagonal(ChessQueen q1, ChessQueen q2) { if (Math.abs(q1.getCol() - q2.getCol()) == Math.abs(q1.getRaw() - q2.getRaw())) { return true; } return false; } }  After that, in our semantic model, we can indicate in which class the implementation of predicates on one line and on one diagonal can be found.\nuse ChessDSL from org.d0sl.examples.chess.ChessDSL  Also in class ChessRobot you can find how the robot calls predicate check board from semantic model.\ntry { board.getBoard().setPieces(pieces); LogicalConstant check = semantic.callPredicate(\u0026quot;check board\u0026quot;, board); if (check.getValue() != Logical.TRUE) { pieces[i][j] = null; board.getBoard().setPieces(pieces); } else { boardPanel.setPiece(pieces[i][j], visit); boardPanel.refreshUI(); if (queenNumber == 7) { return true; } else { if (arrange(pieces, new LinkedList(), queenNumber + 1)) { return true; } else { pieces[i][j] = null; board.getBoard().setPieces(pieces); boardPanel.clear(visit); boardPanel.refreshUI(); } } } } catch (SemanticException e) { e.printStackTrace(); }  The algorithm is as follows: the robot puts the next queen and asks if everything is good. If the answer is positive, the robot tries to put the next queen, and if the answer is negative, the robot removes the last queen and searches for another cell for it. If a situation arises when it is impossible to place the next queen on any square, the robot goes back a step, cutting off the bad field.  "
},
{
	"uri": "https://d0sl.org/en/quick/",
	"title": "Quick start",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Quick start  The simplest way to quickly understand d0sl Semantic Platform is to run our samples. This chapter describes installation process of d0sl SDK and how to run the samples.\n "
},
{
	"uri": "https://d0sl.org/en/quick/requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": "So, our main goal is to give a person the opportunity to describe logical rules in an understandable language. We call it d0sl or Delta Zero Semantic Language.\nFor this, we should to implement the language, as well as provide a convenient editor (or IDE Integrated Development Environment) that would allow to create d0sl documents and even immediately run.\nThere are various ways to reach this, but we chose as a bases the powerfull Jetbrains MPS (Meta Programming System).\nYou should preinstall it from [here](https://www.jetbrains.com/mps/download)  We choose MPS because:\n  MPS IDE is very similar to Intelliji Idea, PyCharm and other Jetbrains products. MPS helps to create powerful DSL (domain specific languages) and helps to create their powerful extensions.\n With MPS we can build plugins of d0sl Language for Intelliji Idea\n We were able to develop a technology that does not depend on the MPS and can be used separately. But we see no reason to abandon the convenience of the MPS where it is possible.   "
},
{
	"uri": "https://d0sl.org/en/d0sl/root/",
	"title": "Semantic and Domain models",
	"tags": [],
	"description": "",
	"content": " There are two kinds of root documents in d0sl - the Semantic Model and the Domain Specific Model.\nSemantic Model is for defining semantic predicates and allows users to define logical rules.\nDomain Specific Model defines objects and functions that can be used in Semantic Model but are specific for domain area. This is similar to C header file.\ngraph TB\rsubgraph Domain Specific Model\rc1[Domain Model]--c2[Domain objects]\rc1--c3[Domain functions]\rend\rsubgraph Semantic Model\ra1[Semantic model]--a2[Predicates]\rend\r\rTo create a semantic or domain model, open the context menu by right-clicking on the sandbox, and then select new/SemanticLanguage/DomainSpecificModel or new/SemanticLanguage/SemanticModel.\nSemantic Model example model ChessAII def use ChessDSL from org.d0sl.examples.chess.ChessDSL def start() means check all ChessDSL.start() end end def def check board(board : ChessBoard) means check all var queens = ChessDSL.get queens(board) for all q1, q2 in queens not ChessDSL.on one line(q1, q2) and not ChessDSL.on one diagonal(q1, q2) end end def end def end ChessAII  Domain Model example domain specific model Math def # Math library # Square root fun sqrt(value : numeric) returns numeric # Sinus and Cosinus fun sin(value : numeric) returns numeric fun cos(value : numeric) returns numeric # Power function fun pow(value : numeric, power : numeric) returns numeric end Math  "
},
{
	"uri": "https://d0sl.org/en/quick/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Install Jetbrains Meta Programming System (MPS) https://www.jetbrains.com/mps/ Clone the repo: git clone https://github.com/d0sl/d0SDK  Alternatevely you can download zip    \nSDK ZIP\n\n In MPS install d0sl plugin from file d0sl_plugin*.zip (choose load plugin from disk option)      Open the project in MPS by choosing the directory cloned (e.g. d0SDK directory) Rebuild the project  "
},
{
	"uri": "https://d0sl.org/en/vision/problems/",
	"title": "Problems of algorithms",
	"tags": [],
	"description": "",
	"content": "Theory of algorithms was created by Alan Turing as a part of effort of Allies during WWII to crack Nazi\u0026rsquo;s Enigma code using so called computers. Computers can understand only exact sets of infrustrions explaining how to solve the problem. Such sets of instructions are called algorithms of computer programs.\nBut we humans in our every day life use logic in our language. Regular person could hardly remember all the instructions even for the washing machine. So we have special people who can do a translation between us humans and computers, which are called software developers or programmers. But the problem is that even after more than 70 year history of computers we still have less than 1% of population who can do such job.\nAlgorithms give computers an exact set of instructions on how to solve the problem. In order to create such algorithm you need to perform certain steps:\n Specify the problem in a manner, which excludes uncertainties. Such specifications should have rigid and logical form. Give it to programmers Eventually after several technological steps (such as architecture, OO design, etc) programmers convert the specification into a program written in some of programming languages Such program can now be translated into a machine code and executed on a computer.  This means that everytime we need to make computers to do something we have to have a computer program, which can be created only by software developers manually. Manual work as everybody knows involves human errors. So #1 problem is the Quality of software programs written by humans. Software bugs can kill any good intention.\nThe more programs we need, the more software developers will be involved. The more computers are used by humanity, the more programs we need, and even more developers will be required. Introduction of mobile phones, IoT and Edge Computing into everyday life creates more and more demand for programmers. Don\u0026rsquo;t forget that every mobile phone is a computer. And we want to put computer chips into things like tea pots and fridges.\nToday we have more computers on the planet than humans. Think about this. Where are we going to get enough software developers in the situation when number of computerized equipment grows much faster than numebr of developers. This problem #2 \u0026ndash; we have not enough programmers.\nAnd problem #3 \u0026ndash; is that mobile communications, robots, edge computing and Iot reiterates the problem of the quality: our civilization becomes more and more dependent on the quality of computer programs.\n"
},
{
	"uri": "https://d0sl.org/en/quick/chess/",
	"title": "Eight Queens puzzle",
	"tags": [],
	"description": "",
	"content": " The eight queens puzzle The eight queens puzzle is the problem of placing eight chess queens on an 8×8 chessboard so that no two queens threaten each other.\nThe problem of finding all solutions to the 8-queens problem can be quite computationally expensive, as there are 4,426,165,368 (i.e., 64C8) possible arrangements of eight queens on an 8×8 board, but only 92 solutions.  The semantic way to solve this problem is as follows:\n Imagine that we have a robot that can arrange randomly eight queens on a chessboard. But he doesn\u0026rsquo;t know whether the position is the right one or not. Then, after each arrangement, the robot asks us if he placed the queens on the board correctly. If we say that is correct, the robot considers the task completed. And if we say what is wrong, the robot tries to place the queens in a different way. In order to determine whether the queens are placed correctly on the chessboard, we will write semantic rules in the d0sl language. For example: For any two queens on a chessboard, it must be true that they are not on the same diagonal, and they are not on the same line.\ndef check board(board : ChessBoard) means check all var queens = ChessDSL.get queens(board) for all q1, q2 in queens not ChessDSL.on one line(q1, q2) and not ChessDSL.on one diagonal(q1, q2) end end def   Next, we show how to run the example and see the code.  "
},
{
	"uri": "https://d0sl.org/en/d0sl/",
	"title": "d0sl language",
	"tags": [],
	"description": "",
	"content": " Chapter 2 d0sl language   d0sl is a semantic language for writing logical rules (or predicates). d0sl is designed to be as simple as possible, but sufficient to record all logical operations, according to the mathematical theory of semantic modeling. d0sl can be easy extended with domain specific functions and objects. Thus d0sl itself is DSL (domain specific language). For d0sl, a language-level extension mechanism is provided. In other words, you can build DSL hierarchies of languages ​​that are transformed into d0sl and can also be executed by the core of d0sl.   "
},
{
	"uri": "https://d0sl.org/en/d0sl/predicate/",
	"title": "Predicate",
	"tags": [],
	"description": "",
	"content": " In mathematical logic, a predicate is commonly understood to be a Boolean-valued function. However, we use the extended notion of a logical type instead of Boolean. And a predicate can return three values: true, false, and none (undefined).\nIf the predicate returns **none**, you must treat this as an exception. For example, a timeout occurred. **none** means that the predicate could not calculate **true** or **false**.  To create a predicate within the semantic model, you must type the keyword def. Then the predicate pattern appears. And you can specify the name of the predicate, its arguments, and the body of the predicate, which is a logical expression.\nThe predicate name may contain spaces. Also you can use not only Latin, but also other national alphabets ..  The predicate pattern is created without arguments. To add an argument, place the cursor inside the parentheses and press Enter or Insert.  The predicate body can be any logical expression of d0sl language: `and`, `or`, `not`, `check all`, `if`, `for all`. But for simplicity, we advise the body of the predicate to start with the `check all` instruction. `check all` instruction is equivalent of `and` instruction with many arguments each is in new line.  Predicate example def check board(board : ChessBoard) means check all var queens = ChessDSL.get queens(board) for all q1, q2 in queens not ChessDSL.on one line(q1, q2) and not ChessDSL.on one diagonal(q1, q2) end end def  "
},
{
	"uri": "https://d0sl.org/en/d0sl/logical/",
	"title": "Logical operations",
	"tags": [],
	"description": "",
	"content": "   Operation Alias Example of true value Example of false value     and and true and true false and true   or or true or false false or false   not not not false not true   check all check check all true check all false    check all instruction is equivalent of and instruction with many arguments each is in new line. You can use check alias to enter check all instruction.\nFor example, the next expressions are equivalent.\nA and B and C and D  check all A B C D end check  "
},
{
	"uri": "https://d0sl.org/en/vision/semantic_tech/",
	"title": "Semantic technology",
	"tags": [],
	"description": "",
	"content": "Semantic modelling is a technology allowing to solve those problems. This is how it works:\n Developer or subject domain expert creates a specification of the application logic (semantic model) in d0SL language in d0SDK IDE. Then d0SDK generates java code of this semantic model This semantic model\u0026rsquo;s java code can now be executed on d0VM (delta 0 virtual machine)  see our Glossary for abreviations\n"
},
{
	"uri": "https://d0sl.org/en/quick/trello/",
	"title": "Trello",
	"tags": [],
	"description": "",
	"content": " Trello sample This example shows how using the semantic model, you can set the rules for moving cards in a Trello board to manage a hypothetical business process.\n\nDownload Trello sample project\n\nSetup project  Extract the archive and open SemanticTrelloBoard folder in MPS as a project(File-\u0026gt;Open-\u0026gt;(select folder in window)). Choose solution on the left pane [s]SemanticTrelloBoard ([s] - icon means that this is solution);\n Right click on it and choose from the popup menu Module Properties -\u0026gt; Java tab -\u0026gt; and click «+» under Libraries section; then choose file SemanticTrelloBoard.jar located in libs folder under SemanticTrelloBoard folder. The window Model Roots will appear, in this window select java_classes from the dropdown list. If you have empty line before line with SemanticTrelloBoard.jar in Libraries section. Then click Apply button and OK button. In the main MPS menu choose Run -\u0026gt; Edit Configurations -\u0026gt; change working directory to SemanticTrelloBoard folder Click Build -\u0026gt; Rebuild project  Configure In predicate \u0026lsquo;start\u0026rsquo; of TrelloBoard semantic model you can see call to domain function TrelloBoard.DLS.start with 4 arguments: app key, delay time in milliseconds, board id, and access_token. This is configuration parameters for TrelloBoardDSL domain model, you may want to change these parameters, if you want to connect this example semantic model with your own trello board. Or just leave those from the example to connect to d0sl example trello board\nHow to get app key and access_token for your own trello board  First, you need to get app key. To do this:  Login to trello Go to https://trello.com/app-key (WARNING!! You must set scope to read,write and expiration to never in url.) Save your api app key and put it into the first argument  Then you need get access_token. Here is the guide on how to get it here. You can get board id from your board’s URL. For example, d0sl sample’s trello board URL is https://trello.com/b/r0W9zMhZ/d0sl-sample-project, and board id is r0W9zMhZ Delay time means time between updates(calls to the predicate checkBoard in the example semantic model)  The name of predicate should be _checkBoard_ and it's args are standard. DO NOT CHANGE THEM!  Run Just choose Run.. from the popup menu on the TrelloBoard model(Right-click on TrelloBoard -\u0026gt; run \u0026lsquo;Node test\u0026rsquo;)\n"
},
{
	"uri": "https://d0sl.org/en/vision/",
	"title": "Vision",
	"tags": [],
	"description": "",
	"content": " Algorithms vs. Logic Road rules book contains logical rules regulating behavior of cars and people on roads. Such road rules book is not really thick, may be about one hundred pages or so. Suppose, you come to a cross road. You use those logic from road rules book to generate an exact algorithm how you are going to behave in this specific situation.\nNow, can you imagine if all possible situations for all possible cross roads were described in road rules book? How many pages such road rules book should contain?;-) That would be an algorithmic approach.\nBut we use logic for road regulations, not algorithms. Because logic allows to represent knowledge in a more compact form. Basically, small set of logical rules allows you to describe very large or even infinite set of situations.\n"
},
{
	"uri": "https://d0sl.org/en/glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "",
	"content": "   Abbreviation Aliases Description     d0SL d0sl, \\(\\Delta_0\\)-language Delta Zero Semantic Language   d0VM [semantic] core, semantic engine, ∑VM semantic virtual machine, which can execute d0SL semantic models   DM domain model, [domain] driver an interface allowing to connect d0VM and semantiс models to the environment   ∑M,SM ∑-model, semantic model a set of definitions of predicates/rules, and specification of corresponding domain models used by those definitions   d0SDK d0SL SDK, SDK Delta Zero Semantic Definition Kit    "
},
{
	"uri": "https://d0sl.org/en/d0sl/if/",
	"title": "If implication",
	"tags": [],
	"description": "",
	"content": " Implication as a if construction in d0sl is false only when the condition is true, and the then part is false. In other words, the implication if(A) then B is an abbreviated entry for the expression not(A) or B.\nUse the `if` keyword, and the editor will provide you with a template for the `if` construct.  If example "
},
{
	"uri": "https://d0sl.org/en/vision/apps/",
	"title": "Applications",
	"tags": [],
	"description": "",
	"content": " \u0026hellip; and use cases Please don\u0026rsquo;t be delluded, semantic modelling is not a silver bullet. It won\u0026rsquo;t allow to create any program for non programmers. Semantic modelling helps to solve so called logical or discrete problems. For example, if you need to solve some specific heavy computational tasks (like neural networks, differential equations, etc) you still need to do traditional programming. UI is still easier to be developed by humans.\nWe see the following areas of applications for semantic modelling:\n Autonomous systems. For example, semantic modelling is being used for many years by mobile telcos, and banks. Business logic and workflow process automation. Embedded systems and edge computing. Industrial IoT Robotics and autonomous equipment  "
},
{
	"uri": "https://d0sl.org/en/vision/contract/",
	"title": "Digital contract example",
	"tags": [],
	"description": "",
	"content": " Цифровой двойник контракта var номер_договора = \u0026quot;34/1\u0026quot; var место = \u0026quot;г. Новосибирск\u0026quot; var дата = \u0026quot;01.02.2020\u0026quot; var исполнитель = \u0026quot;Вычислительные системы\u0026quot; var заказчик = \u0026quot;Контрагент 123\u0026quot;  ДОГОВОР N 34/1 На разработку программного обеспечения и передачу исключительных прав г. Новосибирск\n1 февраля 2020 года\nОбщество с ограниченной ответственностью Научно-производственная компания «Вычислительные Системы», именуемое далее «Исполнитель», в лице Директора Караванова Павла Владимировича, действующего на основании Устава, с одной стороны, и ООО Арс, именуемое далее «Заказчик», в лице Генерального директора Сидорова Георгия Ивановича, действующего на основании Устава, с другой стороны, по отдельности именуемые «Сторона», совместно именуемые «Стороны», заключили настоящий Договор о нижеследующем:\nvar продукт = \u0026quot;Система мониторинга СМС-центра\u0026quot;  1 Термины и определения\n1.1 Программное обеспечение – Программа для ЭВМ Система мониторинга СМС-центра в соответствии с Техническим заданием Заказчика, приведенным в Приложении 1 к настоящему Договору.\n1.2 Оборудование – компьютерное оборудование Заказчика или третей стороны, предназначенное для инсталляции и функционирования на нем Программного обеспечения.\n1.3 Документация – техническая и иная документированная по Программному обеспечению в печатном либо электронном виде.\nvar начало_работ = дата + 5 рабочих дней var дата_окончания = 01.06.2020  2 Предмет договора\n2.1. В силу настоящего договора Исполнитель по заданию Заказчика обязуется разработать Программное обеспечение в соответствии с Техническим заданием Заказчика (далее – «Программное обеспечение»).\n2.2. Исполнитель обязуется передать Заказчику исключительные права на Программные обеспечения. Исключительные права на Программное обеспечение передаются Заказчику с момента подписания сторонами Акта приемки-передачи Программного обеспечения и исключительных прав на Программное обеспечение.\n2.3. Заказчик, в свою очередь, обязуется принять Программное обеспечение, исключительные права на Программное обеспечение, Документацию иные результаты Работ Исполнителя в порядке и в сроки, обусловленные настоящим Договором, а также уплатить Исполнителю вознаграждение, обусловленное настоящим Договором.\n2.4. Дата начала выполнения Работ по настоящему Договору – в течении 5 (Пяти) рабочих дней с даты подписания настоящего Договора\n2.5. Дата окончания Работ, передачи исключительных прав на Программное обеспечение, окончания оказания Услуг – не позднее 01.06.2020.\n2.6. В случае внесения Заказчиком изменений в Техническое задание цена настоящего Договора и сроки исполнения обязательств по нему могут быть изменены Исполнителем.\n3 Цена Договора. Порядок оплаты.\nvar цена_договора = 3 000 000 var аванс = 500 000 var дата_аванса = 15.02.2020 var дата_оплаты = дата_подписания_акта(номер_договора) + 5 рабочих дней  3.1 Цена настоящего Договора составляет 3 000 000 (три миллиона) рублей, НДС не облагается в связи с применением Исполнителем упрощенной системы налогообложения (Глава 26.2 Налогового кодекса РФ).\n3.2 Стоимость Работ по разработке Программного обеспечения по настоящему Договору включает в себя разовый фиксированный платёж за отчуждение исключительных прав на Программное обеспечение.\n3.3 Уплата вознаграждения Исполнителю Заказчиком производится в следующем порядке:\n  500 000 (пятьсот тысяч) рублей, НДС не облагается, Заказчик уплачивает не позднее «15» февраля 2020 года. 2 500 000 (два миллиона пятьсот тысяч) рублей, НДС не облагается, Заказчик уплачивает не позднее 5 (пяти) рабочих дней со дня подписания сторонами Акта приемки-передачи Программного обеспечения и исключительных прав на Программное обеспечение.   3.4. Уплата вознаграждения по настоящему Договору производится платёжными поручениями на расчётный счёт Исполнителя.\nvar дата_согласования_ТЗ = дата + 5 рабочих дней var срок_ответа_на_email = 2 рабочих дня var срок_запуска_автотестов = 2 рабочих дня var срок_проверки_документации = 2 рабочих дня var срок_запуска_приемки = 2 рабочих дня  4 Иные обязанности сторон\n4.1. Исполнитель обязуется:\n 4.1.1. Своевременно и в полном объёме разработать и передать Заказчику Программное обеспечение, передать Заказчику исключительное право на Программное обеспечение, передать Заказчику Документацию, а также выполнить иные Работы и оказать Услуги, предусмотренные настоящим Договором.\n 4.2. Заказчик обязуется:\n 4.2.1. Оказать всё необходимое содействие исполнителю для выполнения его обязательств по настоящему Договору, в том числе, но не ограничиваясь:\n 4.2.1.1. Не позднее 5 (Пяти) рабочих дней с даты подписания настоящего Договора согласовать с Исполнителем окончательный вариант Технического задания.\n4.2.1.2. Предоставить всю имеющуюся документацию на Оборудование и установленное на него программное обеспечение.\n4.2.1.3. Выделить в распоряжение Исполнителя своего технического специалиста, ответственного за взаимодействие с Исполнителем.\n 4.2.2. Предоставлять ответы на запросы исполнителя (электронные письма) по вопросам, связанным с исполнением настоящего Договора, не позднее 2 (Двух) рабочих дней с момента их получения.\n4.2.3. Не позднее 2 (Двух) рабочих дней со дня получения рабочих версий Программного обеспечения, производить их тестирование и предоставлять Исполнителю перечень выявленных недостатков в функционировании Программного обеспечения либо уведомление об их отсутствии.\n4.2.4. Не позднее 2 (Двух) рабочих дней со дня получения рабочих версий Документации, производить их проверку и предоставлять Исполнителю перечень выявленных недостатков в Документации либо уведомление об их отсутствии.\n4.2.5. Не позднее 2 (Двух) рабочих дней после получения соответствующего уведомления от Исполнителя производить приёмку окончательных версий Программного обеспечения, Документации и/или Работ.\n 5 Конфиденциальная информация\n 5.1. Стороны пришли к соглашению, считать конфиденциальной и не подлежащей разглашению (коммерческой тайной) любую информацию, полученную ими по настоящему Договору, включая, но не ограничиваясь: текст настоящего Договора; текст, диаграммы, рисунки любых документов, в том числе технической и коммерческой документации по настоящему Договору; информация о структуре управления любой из Сторон; информация о ценовой и маркетинговой политике любой из сторон; информация о партнёрах и контрагентах Сторон; исходные тексты и исполняемые коды Программного обеспечения; а так же любая иная информация, имеющая пометку «Конфиденциально» и/или «Коммерческая тайна».\n5.2. Каждая из Сторон обязана предпринять адекватные меры по защите конфиденциальной информации, в том числе путём ограничения доступа к ней лиц, непосредственно не связанных с исполнением настоящего Договора. В любом случае меры, предпринимаемые каждой из Сторон по защите Конфиденциальной информации, полученной от другой стороны, должны быть не меньшими, чем предпринимаемые для защиты собственной конфиденциальной информации.\n 6 Ответственность сторон\nvar неустойка_при_задолженности = задолженность * 0.0005 * количество_дней   6.1. При просрочке платежа в соответствии с условиями настоящего Договора и заключаемых в соответствии с ним Дополнительных соглашений, Исполнитель вправе требовать от Заказчика уплаты неустойки из расчёта 0,05 (Ноль целых пять сотых) процента от суммы Задолженности за каждый день просрочки.\n6.2. При просрочке в разработке Программного обеспечении и/или выполнения иных Работ по настоящему Договору Заказчик вправе требовать от Исполнителя уплаты неустойки из расчёта 0,05 (Ноль целых пять сотых) процента от суммы аванса, уплаченного Заказчиком по настоящему Договору.\n6.3. Исполнитель не несет ответственности за любые убытки, возникшие в связи со сбоями и ошибками в функционировании Программного обеспечения, за исключением реального ущерба, причиненного Заказчику в связи с несвоевременным исполнением Исполнителем обязательств по гарантийной технической поддержке в гарантийный период.\n6.4. В иных случаях ответственность Сторон определяется действующим законодательством Российской Федерации.\n6.5. Ни одна из Сторон не несёт ответственности за просрочку в исполнении своих обязательств, если такая просрочка вызвана действиями или бездействием другой Стороны.\n6.6. Сторона, допустившая просрочку исполнения своих обязательств по настоящему Договору, освобождается от ответственности если докажет, что просрочка в исполнении обязательств явилась следствием действия обстоятельств непреодолимой силы (форс-мажорных обстоятельств). Под обстоятельствами непреодолимой силы Стороны подразумевают любые события, находящиеся вне контроля соответствующей Стороны и объективно препятствующие выполнению её обязательств по настоящему Договору, о возможности наступления которых просрочившая сторона не могла разумно предполагать при заключении настоящего Договора, в том числе включая, но не ограничиваясь: пожары, землетрясения, стихийные бедствия, военные действии, забастовки, гражданские волнения, аварии на линиях электроснабжения и связи.\n 7 Иные условия\nvar срок_уведомления_при_смене_реквизитов = 5 рабочих дней var срок_ответа_на_претензию = 5 рабочих дней   7.1. Настоящий Договор вступает в силу со дня его подписания обеими Сторонами и действует до полного исполнения ими обязательств из него вытекающих.\n7.2. Настоящий Договор, включая Приложение 1 составлен в 2 (Двух) подлинных экземплярах на ___ (_______) страницах – по одному для каждой из Сторон.\n7.3. Любая из Сторон, в случае смены реквизитов, указанных в настоящем Договоре обязана не позднее 5 (Пяти) рабочих дней после смены реквизитов письменно уведомить об этом другую Сторону.\n7.4. Любые разногласия, вытекающие из настоящего Договора, Стороны договорились разрешать в досудебном претензионном порядке. Сторона, получившая письменную претензию, обязана не позднее 5 (Пяти) рабочих дней с момента получения такой претензии устранить указанные в ней нарушения, либо направить другой Стороне письменный мотивированный отказ в удовлетворении претензии.\n7.5. В случае если Сторонам не будет достигнуто согласие в досудебном порядке, спор подлежит передаче на рассмотрение Арбитражного суда Новосибирской области в порядке, определяемом законодательством Российской Федерации.\n 8 Реквизиты и подписи сторон.\nИсполнитель:\nЗаказчик:\nДиректор\n"
},
{
	"uri": "https://d0sl.org/en/d0sl/for/",
	"title": "For all",
	"tags": [],
	"description": "",
	"content": " To create for all logical expression, you must type the keyword for. Then the for all pattern appears.\nThe general form of this logical expression is for all x1, x2... xn in listX Expression(x1,...,xn). It means that for every \u0026lt;x1,..,xn\u0026gt; from a list listX an expression Expression(x1, ..., xn) should be true.\nFor all example To calculate the result, a selection of various `` combinations from a certain list is made. If such a selection cannot be made, it is considered that the formula was not calculated and the `for all` expression returns `true`. That is, if the list is empty, or of a smaller dimension than the vector ``, you will end up with a `true`, and the formula inside `for all` will not be calculated.  "
},
{
	"uri": "https://d0sl.org/en/d0sl/var/",
	"title": "Variables",
	"tags": [],
	"description": "",
	"content": " You can use local variables inside check all block by entering var keyword.\nThere are important restrictions on the use of variables. First, you cannot change their value after it has been calculated. Secondly, each time the predicate is called, the value of a local variable is calculated only once. That is, if you use the variable reference several times within the predicate, the value will be calculated only when you first use  Variable example # Testing for sin \u0026amp; cos def test() means check all var angle = 35 var cosinus = Math.cos(angle) var sinus = Math.sin(angle) var sum of squares = Math.pow(cosinus, 2) + Math.pow(sinus, 2) # considering the features of the library java.lang.Math # and inaccurate calculations when converting degrees to radians sum of squares \u0026lt;= 1 sum of squares \u0026gt;= 0.999999 end end def  "
},
{
	"uri": "https://d0sl.org/en/d0sl/domain/",
	"title": "Domain model",
	"tags": [],
	"description": "",
	"content": " Domain object Inside the domain model, you can create types using the keyword type, and then to use objects of this type in the arguments of domain functions and semantic predicates.\nDomain function Inside the domain model, you can define domain functions using the keyword fun, and then to use this functions in semantic predicates.\n"
},
{
	"uri": "https://d0sl.org/en/vision/math/",
	"title": "Mathematical foundations",
	"tags": [],
	"description": "",
	"content": "Originally the mathematical theory behind this technology was developed in Sobolev Institute of Mathematics by three famous mathematicians Yuri L. Yershov, Sergey S. Goncharov and Dmitry I. Sviridenko.\nSo the idea behind semantic modelling is how to make it simpler for non-programmers to communicate with computers. Instead of creating yet another algorithmic language for programming, semantic modelling is focusing on using logical language allowing non-programmers to effectively explain computers what to do (opposed to algorithms describing how). Such semantic models are called executable specifications.\nd0sl stands for \\( \\Delta_0 \\) (delta zero)Semantiс Language.\n- `d0sl` is a declarative executable specifications language, which is a constructive subset of the first order predicate logic language. - `d0sl` syntax [here](/en/d0sl/)  Mathematical definition of \\( \\Delta_0 \\)-formulas here. If you are interested in math theory behind please check this list of articles\n"
},
{
	"uri": "https://d0sl.org/en/d0sl/use/",
	"title": "Use",
	"tags": [],
	"description": "",
	"content": "In Semantic Model the use statement allows you to include other Semantic and Domain models. This means that if you included another semantic model through the use statement, you can call its predicates. Similarly it works with a domain model.\nFor example, below we include AutodromeDSL domain model:\nuse AutodromeDSL from org.d0sl.examples.auto.AutodromeDSL  After that we can call domain functions defined in AutodromeDSL in our Semantic Model like this:\ndef can stop2(car : Car) means check all not AutodromeDSL.wall ahead(car) not AutodromeDSL.road sign(car) AutodromeDSL.car ahead(car) end end def  You can specify the implementation class for the domain model in the `from` field (for the Semantic Model, this is not necessary). The implementation class needs to be specified only if you want to run the model inside the MPS project.  If you specified an implementation class, it should be accessible via dependencies in your MPS project. The implementation can be added either through the jar file, or implemented directly in the MPS in a separate solution, as implemented for Chess and Autodrome examples.  "
},
{
	"uri": "https://d0sl.org/en/d0sl/editor/",
	"title": "Editor tips",
	"tags": [],
	"description": "",
	"content": "   Alias Effect     Ctrl+space Code completion   Alt+enter Intentions menu   Ctrl+w Item (incremental) selection   def Creates predicate definition   use Creates use keyword   check Check all keyword   and, or, not Logical operation   \u0026ldquo; \u0026rdquo;\u0026ldquo;, string value   for For all keyword   if Implication (if)   Insert, enter When needs to insert argument for predicates or functions   var Local variable (inside check-all)   fun Creates function in Domain Model   typedef Creates domain type in Domain Model    "
},
{
	"uri": "https://d0sl.org/en/vision/articles/",
	"title": "Articles",
	"tags": [],
	"description": "",
	"content": " Semantic modelling for robots applications  Goncharov S.S., Ershov Yu.L., Sviridenko D.I. \u0026ldquo;Methodology aspects of the semantic programming // Scientific knowledge: logic, notions, structure.\u0026rdquo; – Novosibirsk, Nauka 1987, pp. 154-184. S.S. Goncharov, D.I. Sviridenko \u0026ldquo;Mathematical Foundations of Semantic Programming Paper.Academy of Science of USSR.\u0026rdquo;\u0026ndash;1986.\u0026ndash; T.289,No 6 S.S. Goncharov, D.I. Sviridenko \u0026ldquo;Σ-Programming Amer. Math. Soc. Transl.\u0026rdquo; (2) Vol. 142, 1989. Available online D.I. Sviridenko \u0026ldquo;Introduction into Semantic Smart Contracts\u0026rdquo; Available online V.Gumirov, P.Matyukov, D.Palchunov, \u0026ldquo;Semantic Domain Specific Languages\u0026rdquo;, IEEE, 2018 (перевод препринта на русский язык доступен http://bit.ly/sDSL-RU) S. Goncharov, S. Ospichev, D. Ponomaryov, D. Sviridenko, “The expressiveness of looping terms in the semantic programming”, Sib. Èlektron. Mat. Izv., 17 (2020), 380–394 Available online S.S. Goncharov, D.I. Sviridenko, “Recursive terms in semantic programming”, Sibirsk. Mat. Zh., 59:6 (2018),1279–1290 Available online S.S. Goncharov, D.I. Sviridenko, “Mathematical foundations of semantic programming”, Dokl. Akad. Nauk SSSR, 289:6 (1986), 1324–1328 Available online Goncharov S.S., Sviridenko D.I., “Logical Language of Description of Polynomial Computing”, Doklady Mathematics, 99:2 (2019), 121–124 Available online S.S. Goncharov, “Conditional terms in semantic programming”, Siberian Math. J., 58:5 (2017), 794–800 Available online Gumirov V., Matyukov P., \u0026ldquo;Method for presenting information when conducting distributed transactions and structure for implementing same\u0026rdquo;, US Patent US9226154B2 Available online Gumirov V.S., Matyukov P.Y., Palchunov D.E. \u0026ldquo;Semantic Domain-specific Languages\u0026rdquo; // In: 2019 International Multi-Conference on Engineering, Computer and Information Sciences (SIBIRCON), Novosibirsk, Russia, 21-27 Oct. 2019. IEEE Press, 2019. P. 0955–0960. Available online Gumirov V.S., Palchunov D.E., \u0026ldquo;System and method for selection of content for displaying to user\u0026rdquo;, RU Patent RU2595530C1 Available online Galieva A.G., Palchunov D.E. \u0026ldquo;Logical Methods for Smart Contract Development\u0026rdquo; // In: 2019 International Multi-Conference on Engineering, Computer and Information Sciences (SIBIRCON), Novosibirsk, Russia, 21-27 Oct. 2019. IEEE Press, 2019. P. 0881–0885. Available online D.E. Palchunov ; G.E. Yakhyaeva \u0026ldquo;Integration of Fuzzy Model Theory and FCA for Big Data Mining 2019\u0026rdquo; International Multi-Conference on Engineering, Computer and Information Sciences (SIBIRCON) Available online Sergey Goncharov; Dmitry Sviridenko \u0026ldquo;Semantic Modeling and Hybrid Models 2019 International Multi-Conference on Engineering\u0026rdquo;, Computer and Information Sciences (SIBIRCON) Available online Palchunov D.E., Yakhyaeva G.E. \u0026ldquo;Fuzzy logics and fuzzy model theory // Algebra and Logic\u0026rdquo;, vol. 54, no. 1, 2015, pp. 74-80. DOI: 10.1007/s10469-015-9326-9 Available online D.E. Palchunov, G.E. Yakhyaeva. \u0026ldquo;Interval Fuzzy Algebraic Systems. In: Mathematical Logic in Asia. Proceedings of the 9th Asian Logic Conference\u0026rsquo;05\u0026rdquo;, World Scientific Publishers, 2006, p. 191-202. Available online \u0026ldquo;Comparison of relational methods and attribute-based methods for data mining in intelligent systems\u0026rdquo; B. Kovalerchuk; E. Vityaev - Proceedings of the 1999 IEEE International Symposium on Intelligent Control Intelligent Systems and Semiotics (Cat. No.99CH37014) Available online \u0026ldquo;Probabilistic Dynamic Logic of Phenomena and Cognition\u0026rdquo; Evgenii Vityaev; Boris Kovalerchuk; Leonid Perlovsky; Stanislav Smerdov - The 2010 International Joint Conference on Neural Networks (IJCNN) Available online Evgenii Vityaev, Boris Kovalerchuk \u0026ldquo;Empirical Theories Discovery based on the Measurement Theory. Mind and Machine\u0026rdquo;, v.14, #4, 551-573, 2004 (preliminary version) Available online Evgenii Vityaev, Boris Kovalerchuk \u0026ldquo;Ontological Data Mining. Uncertainty Modeling: Dedicated to Professor Boris Kovalerchuk on his Anniversary. Studies in Computational Intelligence 683\u0026rdquo;, V. Kreinovich (ed.), Springer, 2017, pp. 277-292. Available online E.E. Vityaev, A.V. Demin. \u0026ldquo;Cognitive architecture based on the functional systems theory.\u0026rdquo; Procedia Computer Science 145C (2018) pp. 623-628. Available online Vityaev E.E. \u0026ldquo;A formal model of neuron that provides consistent predictions. Biologically Inspired Cognitive Architectures 2012\u0026rdquo;. Proceedings of the Third Annual Meeting of the BICA Society (A. Chella, R.Pirrone, R. Sorbello, K.R. Johannsdottir, Eds). \u0026ldquo;In Advances in Intelligent Systems and Computing\u0026rdquo;, v.196, Springer: Heidelberg, New York, Dordrecht, London. 2013, pp. 339-344. Available online Evgenii E. Vityaev, Alexander V. Demin \u0026ldquo;Recursive subgoals discovery based on the functional systems theory.\u0026rdquo; Biologically Inspired Cognitive Architectures 2011, A.V.Samsonovich, K.R.Johannsdottir (Eds), IOS Press, 2011, pp.425-430 Available online Demin A.V., Vityaev E.E. \u0026ldquo;Adaptive control of multiped robot\u0026rdquo; // Procedia Computer Science 145C (2018) pp. 629-634. Available online Anton Kolonina, Evgenii Vityaev, Yuriy Orlov \u0026ldquo;Cognitive Architecture of Collective Intelligence Based on Social Evidence\u0026rdquo; // 7th Annual International Conference on Biologically Inspired Cognitive Architectures, BICA 2016, 16-19 July, 2016 in New York City, NY, USA. Procedia Computer Science, v.88, 2016, pp. 475-481. Available online A.V. Demin, E.E. Vityaev \u0026ldquo;Learning in a virtual model of the C. elegans nematode for locomotion and chemotaxis.\u0026rdquo; Biologically Inspired Cognitive Architectures. (2014) 7, 9-14. Available online  "
},
{
	"uri": "https://d0sl.org/en/d0sl/run/",
	"title": "How to run model in MPS",
	"tags": [],
	"description": "",
	"content": "If you define the predicate `start()` without parameters in your semantic model, it will be called automatically when you run the model through the context menu in the MPS project.  For example, the following start() predicate in the example about the Autodrome first sets up obstacles and road signs on the autodrome field, and then starts the graphical user interface by calling the another start domain function.\ndef start() means check all # set walls AutodromeDSL.add wall(5, 1) AutodromeDSL.add wall(5, 14) AutodromeDSL.add wall(10, 8) # set road signs AutodromeDSL.add road sign(4, 5, \u0026quot;south\u0026quot;) AutodromeDSL.add road sign(6, 9, \u0026quot;north\u0026quot;) AutodromeDSL.add road sign(7, 7, \u0026quot;east\u0026quot;) AutodromeDSL.start(10, 500) end end def  "
},
{
	"uri": "https://d0sl.org/en/d0sl/articles/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Mathematical foundations of semantic programming/modelling  Goncharov S.S., Ershov Yu.L., Sviridenko D.I. Methodology aspects of the semantic programming // Scientific knowledge: logic, notions, structure. – Novosibirsk, Nauka 1987, pp. 154-184. S.S. Goncharov, D.I. Sviridenko Mathematical Foundations of Semantic Programming Paper.Academy of Science of USSR.\u0026ndash;1986.\u0026ndash; T.289,No 6 S.S. Goncharov, D.I. Sviridenko Σ-Programming Amer. Math. Soc. Transl. (2) Vol. 142, 1989. Available online: https://goo.gl/QcocUc D.I. Sviridenko Introduction into Semantic Smart Contracts https://goo.gl/zHg1pt V.Gumirov, P.Matyukov, D.Palchunov, Semantic Domain Specific Languages, IEEE, 2018 (перевод препринта на русский язык доступен http://bit.ly/sDSL-RU)  "
},
{
	"uri": "https://d0sl.org/en/d0sl/delta0_math_def/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Mathematical definition of \\(\\Delta_0\\)-formulas Definition\n If \\(P \\) is a predicate symbol, \\(P \\in \\sigma \\), and \\( 𝑡_1,\u0026hellip;,t_n \\) are symbols of constants of the signature \\(\\sigma\\), or variables, then \\( P(𝑡_1,\u0026hellip;,t_n)\\) is a \\(\\Delta_0 \\)-formula. If \\( \\phi \\) and \\( \\psi \\) are \\( \\Delta_0 \\)-formulas, then \\( \\phi \\wedge \\psi, \\phi \\vee \\psi , \\phi \\rightarrow \\psi, \\neg \\psi \\) are \\( \\Delta_0 \\)-formulas. If \\( \\phi \\) is a \\( \\Delta_0 \\)-formula, 𝑥 is a variable, and 𝑙 is a finite list, then \\( (\\forall x \\in l)\\phi (x) \\) and \\( (\\exists x \\in l)\\phi (x) \\) are \\( \\Delta_0 \\)-formulas. There are no other \\( \\Delta_0 \\)-formulas.  "
},
{
	"uri": "https://d0sl.org/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://d0sl.org/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start }\n.ghContributors \u0026gt; div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label{ padding-left: 4px ; } .ghContributors \u0026gt; div span{ font-size: x-small; padding-left: 4px ; }\n  @kuruhuru\n\n @vitgum\n\n\n"
},
{
	"uri": "https://d0sl.org/en/",
	"title": "d0sl",
	"tags": [],
	"description": "",
	"content": " d0SL: Delta Zero Semantic Language d0SL is a next step generation of so called Business Rules Engines (BRE). Just like regular BRE\u0026rsquo;s d0SL allows you to implement business logic of your system by using declarative logical specifications language.\nMain components of `d0SL`: 1. `d0SL` language itself 2. `d0VM` -- semantic virtual machine which executes _semantic models_ written in `d0SL` language 3. `d0SDK` -- an _IDE_ for creating semantic models, which also includes `d0SL` examples 4. _Domain models_ (or so called _drivers_) which serve to link the semntic models with external systems, and allow you to define logical rules, using terms of the subject area.  There are several important advantages over traditional BRE:   d0SL has very simple purely logical syntax, which does not require any programming skills from users who use it to specify business logic. Everyone who has basic understanding of logic can start using it in a matter of several hours unlike other BREs, which require significant investment of time to learn and special programming skills to understand and write business rules.\n d0SL scales from embedded systems to enterprise level. Its footprint is very lightweight and can be deployed even on embedded systems like Raspberry PI. On the other hand, d0SL can be used on enterprise level (we have carrier grade version of d0SL called Eyeline SDP, which is used by several mobile telcos, banks etc).\n d0SL has very clear intuitive semantics for non programmers, because d0SL is based on a pure Delta 0 subset of first order predicate logic and has mathematically proven semantics. Unlike d0SL other BREs have non clear semantics which makes them much more difficult to use.\n d0SL allows to create DSLs (domain specific languages) which can be used to create business rules not only by your employees, but also by your end users.\n d0SL provides IDE out of the box, which simplifies creation of logical rules. We supply this in a form of d0SL plugin for JetBrains MPS. This simplifies the creation of semantic logical models because this plugin helps the user to create syntactically correct semantic models.\n d0SL allows easy integration with your existing software by implementing integration drivers (so called domain models).\n d0SL allows to implement one set of logical rules on top of the other sets of logical rules (a set of logical rules is called semantic model). In turn this allows to increase level of abstraction as much as you need. And this is important for you to create a Domain Specific Language for your users/employees which is easy to learn and easy to use.\n   We like the word `d0SL` and we will use it both for the language and for the system as a whole, or even for the components mentioned above. The meaning should be clear from the context , for example, `d0SL` language, `d0SL` virtual machine etc.  You can think of `d0SL` as a logical operating system which can execute _semantic models_ written in `d0SL` language. As any OS `d0SL` needs _drivers_ to communicate with an environment: such drivers in `d0SL` are called **domain models**. Another similar analogy is the JDBC drivers, which connect to the database.    How `d0SL` can save humanity from robots rebellion?   ## The industrial revolution has us to belive in the science fiction Remember the three Laws of Robotics which govern the behaviour of Isaac Asimov\u0026rsquo;s fictional Positronic Robots. They were formally stated by Asimov in his story \u0026ldquo;Runaround\u0026rdquo; (March 1942):\n  A robot may not injure a human being or, through inaction, allow a human being to come to harm.\n A robot must obey orders given it by human beings except where such orders would conflict with the First Law.\n A robot must protect its own existence as long as such protection does not conflict with the First or Second Law.\n  New industrial revolution begins now.\n Neural networks drive a car instead of a person. Complex mechanisms and systems work longer and longer without human participation. We face robots more and more often.  But there is a recognized problem in the field of artificial intelligence. Namely the black box problem. Even a neural network technician does not know what is going on inside.\nWho is responsible for robots? Who controls them if programmers and datasсientists cannot understand the algorithms by which artifitial intelligince operates?\nd0SL technology can be embedded in AI, IoT, autonomous systems of any complexity. In this case, it becomes possible to determine the logical rules of the behavior of such systems in a clear language of human logic. For example, it can implement the three Laws of Robotics.\n \u0026lt;/div\u0026gt;  \n"
},
{
	"uri": "https://d0sl.org/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]