[
{
	"uri": "/en/quick/chess/sample/",
	"title": "Project details",
	"tags": [],
	"description": "",
	"content": " To run the chess sample  Find a semantic model ChessAII in org.d0sl.examples/sandbox Open the context menu on it by pressing the right mouse button. And select Run Node ChessAII.  To change semantic Semantic model is defined in sandbox/ChessAII. When the robot places the queens it calls check board predicate. In the semantic model in advance prepared several different predicates check board. Just change the name of the current check board predicate, and rename some other (e.g. check board1 name to check board. And you can see how the behavior of the robot changes depending on the given semantics.\nFor example, the following model will forbid a robot to put queens on one line, but he will be able to arrange them on one diagonal.\ndef check board2(board : ChessBoard) means check all var queens = ChessDSL.get queens(board) for all q1, q2 in queens not ChessDSL.on one line(q1, q2) end end def  After each change of the model, do not forget to rebuild the MPS solution (Ctrl+F9).\n\rJava part You can find the Java part of the example in org.d0sl.examples/chess\n First of all, pay attention to the ChessDSL class, which, using annotations, indicates the domain specific functions to which we refer in our semantic model. For example\n /** Represents a DSL for task: Arrangement of chess queens */ @DomainModel(name = \u0026quot;ChessDSL\u0026quot;) public class ChessDSL { \u0026lt;...SKIPPED...\u0026gt; /** Check if two queens are in the same horizontal or vertical @param @return */ @DomainFunction(name = \u0026quot;on one line\u0026quot;) public boolean onOneLine(ChessQueen q1, ChessQueen q2) { if (q1.getCol() == q2.getCol() || q1.getRaw() == q2.getRaw()) { return true; } return false; } /** Check if two queens are in the same diagonal @param @return */ @DomainFunction(name = \u0026quot;on one diagonal\u0026quot;) public boolean onOneDiagonal(ChessQueen q1, ChessQueen q2) { if (Math.abs(q1.getCol() - q2.getCol()) == Math.abs(q1.getRaw() - q2.getRaw())) { return true; } return false; } }  After that, in our semantic model, we can indicate in which class the implementation of predicates on one line and on one diagonal can be found.\nuse ChessDSL from org.d0sl.examples.chess.ChessDSL  Also in class ChessRobot you can find how the robot calls predicate check board from semantic model.\ntry { board.getBoard().setPieces(pieces); LogicalConstant check = semantic.callPredicate(\u0026quot;check board\u0026quot;, board); if (check.getValue() != Logical.TRUE) { pieces[i][j] = null; board.getBoard().setPieces(pieces); } else { boardPanel.setPiece(pieces[i][j], visit); boardPanel.refreshUI(); if (queenNumber == 7) { return true; } else { if (arrange(pieces, new LinkedList(), queenNumber + 1)) { return true; } else { pieces[i][j] = null; board.getBoard().setPieces(pieces); boardPanel.clear(visit); boardPanel.refreshUI(); } } } } catch (SemanticException e) { e.printStackTrace(); }  The algorithm is as follows: the robot puts the next queen and asks if everything is good. If the answer is positive, the robot tries to put the next queen, and if the answer is negative, the robot removes the last queen and searches for another cell for it. If a situation arises when it is impossible to place the next queen on any square, the robot goes back a step, cutting off the bad field.\n\r"
},
{
	"uri": "/en/quick/",
	"title": "Quick start",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Quick start  The simplest way to quickly understand d0sl Semantic Platform is to run our samples. This chapter describes installation process of d0sl SDK and how to run the samples.\n "
},
{
	"uri": "/en/quick/requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": "So, our main goal is to give a person the opportunity to describe logical rules in an understandable language. We call it d0sl or Delta Zero Semantic Language.\nFor this, we should to implement the language, as well as provide a convenient editor (or IDE Integrated Development Environment) that would allow to create d0sl documents and even immediately run.\nThere are various ways to reach this, but we chose as a bases the powerfull Jetbrains MPS (Meta Programming System).\nYou should preinstall it from here\n\rWe choose MPS because:\n  MPS IDE is very similar to Intelliji Idea, PyCharm and other Jetbrains products. MPS helps to create powerful DSL (domain specific languages) and helps to create their powerful extensions.\n With MPS we can build plugins of d0sl Language for Intelliji Idea\n We were able to develop a technology that does not depend on the MPS and can be used separately. But we see no reason to abandon the convenience of the MPS where it is possible.   "
},
{
	"uri": "/en/d0sl/root/",
	"title": "Semantic and Domain models",
	"tags": [],
	"description": "",
	"content": " There are two kinds of root documents in d0sl - the Semantic Model and the Domain Specific Model.\nSemantic Model is for defining semantic predicates and allows users to define logical rules.\nDomain Specific Model defines objects and functions that can be used in Semantic Model but are specific for domain area. This is similar to C header file.\ngraph TB subgraph Domain Specific Model c1[Domain Model]--c2[Domain objects] c1--c3[Domain functions] end subgraph Semantic Model a1[Semantic model]--a2[Predicates] end \rTo create a semantic or domain model, open the context menu by right-clicking on the sandbox, and then select new/SemanticLanguage/DomainSpecificModel or new/SemanticLanguage/SemanticModel.\nSemantic Model example model ChessAII def use ChessDSL from org.d0sl.examples.chess.ChessDSL def start() means check all ChessDSL.start() end end def def check board(board : ChessBoard) means check all var queens = ChessDSL.get queens(board) for all q1, q2 in queens not ChessDSL.on one line(q1, q2) and not ChessDSL.on one diagonal(q1, q2) end end def end def end ChessAII  Domain Model example domain specific model Math def # Math library # Square root fun sqrt(value : numeric) returns numeric # Sinus and Cosinus fun sin(value : numeric) returns numeric fun cos(value : numeric) returns numeric # Power function fun pow(value : numeric, power : numeric) returns numeric end Math  "
},
{
	"uri": "/en/quick/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Install Jetbrains Meta Programming System (MPS) https://www.jetbrains.com/mps/ Clone the repo: git clone https://github.com/kirikprotocol/examples-d0sl In MPS install d0sl plugin from file d0sl_plugin*.zip (choose load plugin from disk option)      Open the project in MPS by choosing the directory cloned (e.g. examples-d0sl directory) Rebuild the project  "
},
{
	"uri": "/en/quick/chess/",
	"title": "Eight Queens puzzle",
	"tags": [],
	"description": "",
	"content": " The eight queens puzzle The eight queens puzzle is the problem of placing eight chess queens on an 8×8 chessboard so that no two queens threaten each other.\nThe problem of finding all solutions to the 8-queens problem can be quite computationally expensive, as there are 4,426,165,368 (i.e., 64C8) possible arrangements of eight queens on an 8×8 board, but only 92 solutions.\n\rThe semantic way to solve this problem is as follows:\n Imagine that we have a robot that can arrange randomly eight queens on a chessboard. But he doesn\u0026rsquo;t know whether the position is the right one or not. Then, after each arrangement, the robot asks us if he placed the queens on the board correctly. If we say that is correct, the robot considers the task completed. And if we say what is wrong, the robot tries to place the queens in a different way. In order to determine whether the queens are placed correctly on the chessboard, we will write semantic rules in the d0sl language. For example: For any two queens on a chessboard, it must be true that they are not on the same diagonal, and they are not on the same line.  def check board(board : ChessBoard) means check all var queens = ChessDSL.get queens(board) for all q1, q2 in queens not ChessDSL.on one line(q1, q2) and not ChessDSL.on one diagonal(q1, q2) end end def  Next, we show how to run the example and see the code.\n\r"
},
{
	"uri": "/en/d0sl/predicate/",
	"title": "Predicate",
	"tags": [],
	"description": "",
	"content": " In mathematical logic, a predicate is commonly understood to be a Boolean-valued function. However, we use the extended notion of a logical type instead of Boolean. And a predicate can return three values: true, false, and none (undefined).\nIf the predicate returns none, you must treat this as an exception. For example, a timeout occurred. none means that the predicate could not calculate true or false.\n\rTo create a predicate within the semantic model, you must type the keyword def. Then the predicate pattern appears. And you can specify the name of the predicate, its arguments, and the body of the predicate, which is a logical expression.\nThe predicate name may contain spaces. Also you can use not only Latin, but also other national alphabets ..\n\rThe predicate pattern is created without arguments. To add an argument, place the cursor inside the parentheses and press Enter or Insert.\n\rThe predicate body can be any logical expression of d0sl language: and, or, not, check all, if, for all. But for simplicity, we advise the body of the predicate to start with the check all instruction. check all instruction is equivalent of and instruction with many arguments each is in new line.\n\rPredicate example def check board(board : ChessBoard) means check all var queens = ChessDSL.get queens(board) for all q1, q2 in queens not ChessDSL.on one line(q1, q2) and not ChessDSL.on one diagonal(q1, q2) end end def  "
},
{
	"uri": "/en/d0sl/",
	"title": "d0sl language",
	"tags": [],
	"description": "",
	"content": " Chapter 2 d0sl language   d0sl is a semantic language for writing logical rules (or predicates). d0sl is designed to be as simple as possible, but sufficient to record all logical operations, according to the mathematical theory of semantic modeling. d0sl can be easy extended with domain specific functions and objects. Thus d0sl itself is DSL (domain specific language). For d0sl, a language-level extension mechanism is provided. In other words, you can build DSL hierarchies of languages ​​that are transformed into d0sl and can also be executed by the core of d0sl.   "
},
{
	"uri": "/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Thanks to them  for making Open Source Software a better place !\n.ghContributors{\rdisplay:flex;\rflex-flow: wrap;\ralign-content: flex-start\r}\r.ghContributors  div{\rwidth: 50% ;\rdisplay: inline-flex;\rmargin-bottom: 5px;\r}\r.ghContributors  div label{\rpadding-left: 4px ;\r}\r.ghContributors  div span{\rfont-size: x-small;\rpadding-left: 4px ;\r}\r\r\r@kuruhuru\r20 commits\r\r\r@vitgum\r1 commits\r\r "
},
{
	"uri": "/en/",
	"title": "Learn d0sl Semantic Platform",
	"tags": [],
	"description": "",
	"content": " Learn d0sl Semantic Platform Our goal is to develop a platform for automatic decision making based on a semantic approach.\nBy the semantic approach, we understand that people will be able to describe the rules in a language of logic, language that everyone understands, and is quite simple to use. Language to exclude everything superfluous, and only the most important to remain.\nRemember the three Laws of Robotics which govern the behaviour of Isaac Asimov\u0026rsquo;s fictional Positronic Robots were formally stated by Asimov in his story \u0026ldquo;Runaround\u0026rdquo; (March 1942):\n\r A robot may not injure a human being or, through inaction, allow a human being to come to harm.\n A robot must obey orders given it by human beings except where such orders would conflict with the First Law.\n A robot must protect its own existence as long as such protection does not conflict with the First or Second Law.\n  This is exactly what we want to turn into reality! Now there is a new industrial revolution. Neural networks drive a car instead of a person. Complex mechanisms and systems work longer and longer without human participation.\nBut there is a recognized problem in the field of artificial intelligence. Namely the black box problem. Even a neural network technician does not know what is going on inside.\nOur project is to help humanity to control artificial intelligence, autonomous systems (or even business processes) by using understandable domain specific language and human logic.\n\rgraph TB\rsubgraph Or even embedding\rc1[fa:fa-robot Robot]--c2[fa:fa-car Car]\rc3[fa:fa-user Human logic]--c4[fa:fa-brain d0sl]\rc4--c1\rend\rsubgraph With d0sl control\ra1[fa:fa-robot Robot]--a2[fa:fa-brain d0sl]\ra4[fa:fa-user Human logic]--a2[fa:fa-brain d0sl]\ra2--a3[fa:fa-car Car]\rend\rsubgraph Lone neural robot\rb1[fa:fa-robot Robot]--b2[fa:fa-car Car]\rend\r\r"
},
{
	"uri": "/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]